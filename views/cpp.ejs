<!DOCTYPE html>
<html lang="en">

<head>
    <title>Othello MCTS beta</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
        integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.7.0.js"
        integrity="sha256-JlqSTELeR4TLqP0OG9dxM7yDPqX1ox/HfgiSLBj8+kM=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx"
        crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap-switch-button@1.1.0/css/bootstrap-switch-button.min.css"
        rel="stylesheet">
    <script
        src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap-switch-button@1.1.0/dist/bootstrap-switch-button.min.js"></script>
    <!--prism-->
    <script src="prism.js"></script>
    <link rel="stylesheet" href="prism.css">
    <script src="function.js"></script>
    <style>
        body {
            font-family: "Lato", sans-serif
        }

        .mySlides {
            display: none
        }

        .control-box {
            background-color: #dfdfdf;
            padding: 0px;
        }

        .box {
            width: 50px;
            height: 50px;
            text-align: center;
            color: #ffffff;
            vertical-align: middle;
            font-weight: bold;
            font-size: 18px;
            background-color: rgb(4, 150, 109);
        }

        .empty:hover {
            cursor: pointer;
            background-color: rgb(6, 117, 85);
        }

        .black {
            background-image: url('image/black.png');
            background-repeat: no-repeat;
            background-size: cover;
        }

        .white {
            background-image: url('image/white.png');
            background-repeat: no-repeat;
            background-size: cover;
        }

        .black-legal {
            background-image: url('image/blackLegal.png');
            background-repeat: no-repeat;
            background-size: cover;
        }

        .white-legal {
            background-image: url('image/whiteLegal.png');
            background-repeat: no-repeat;
            background-size: cover;
        }

        .pawn {
            height: 70px;
        }

        .control-box-element {
            margin-top: 10px;
        }

        button {
            border-radius: 10%;
        }
    </style>
</head>

<body>

    <!-- Navbar -->
    <div class="w3-top">
        <div class="w3-bar w3-black w3-card">
            <a class="w3-bar-item w3-button w3-padding-large w3-hide-medium w3-hide-large w3-right"
                href="javascript:void(0)" onclick="myFunction()" title="Toggle Navigation Menu"><i
                    class="fa fa-bars"></i></a>
            <div class="w3-bar-item w3-padding-large">Othello MCTS</div>
            <a href="/" class="w3-bar-item w3-button w3-padding-large">首頁</a>
            <a href="/introduce" class="w3-bar-item w3-button w3-padding-large w3-hide-small">專案簡介</a>
            <a href="#" class="w3-bar-item w3-button w3-padding-large w3-hide-small">MCTS</a>
            <a href="/cpp" class="w3-bar-item w3-button w3-padding-large w3-hide-small">C++</a>
        </div>
    </div>

    <!-- Page content -->
    <div class="w3-content" style="max-width:2000px;margin-top:46px">
        <!-- The Band Section -->
        <div class="w3-container w3-content w3-center w3-padding-16" style="width:700px">
            <h1 class="w3-wide w3-center">C++程式碼</h1>
            <pre><code class='language-js line-numbers'>
                
        #include&ltiostream&gt
        #include&ltstdio.h&gt
        #include&ltalgorithm&gt
        #include&ltvector&gt
        #include&ltutility&gt
        #include&lttuple&gt
        #include&ltset&gt
        #include &ltcmath&gt
        #include&ltfstream&gt
        #include "json.hpp"
        using json = nlohmann::json;
        using namespace std;

        class State{
            /*****************************

            變數定義
            table:棋盤 (-1空, 0白, 1黑)
            color:下棋方(0白,1黑)
            legalStepList:下棋方合法步陣列
            numberOfPieces[2]:棋子數(0白,1黑)

            ******************************/
            friend class MCTS;
            private:
                int table[8][8];
                vector&ltint&gt legalStepList;
                int numberOfPieces[2];
                int color;
                bool gameOver;
            /*****************************

            函數定義
            move(state, position):下子並更新棋局(state)
            count(table): 計算白子及黑子個數
            updateLegalStepList(table, color): 更新下棋方合法步陣列
            findLegalStep(table,position,direction,color): 以position座標與direction出發尋找合法步 -1:沒找到
            flip(table,position,direction,color): 以position座標與direction出發按規則將棋子翻轉成color

            ******************************/
            public:
                State();
                void move(int position);
                void updateNumberOfPieces();
                void updateLegalStepList();
                int findLegalStep(int position,int direction);
                bool flip(int position,int direction);
                bool isLegal(int position);
                bool isGameOver();
                void print();
                State(json inputData);//用(棋局 + 新步) json建構
                json toJson();//轉為棋局json檔
        };
        class Node{
            public:
                State state;
                int wins,loses,simulations,newPosition;
                Node *parent;
                vector&ltNode*&gt children;
                Node(State state);
                void print();
        };
        class MCTS{
            Node *root;
            /*****************************

            函數定義
            MCTS(state):初始化，放上root並擴展一次
            predict(&root):用蒙特卡洛樹搜索尋找落子位置
            selection(&root):用UCB尋找目標節點並回傳
            expansion(&node):擴展節點
            rollout(&node):仿真，隨機走到底，回傳-1平手、0白贏、1黑贏
            backpropagation(&node):向父節點更新仿真次數、勝利次數

            ******************************/
            public:
                MCTS(State state);
                ~MCTS();
                void deleteNode(Node* node);
                double UCB(Node*);
                int predict();
                Node* selection(Node*);
                void expansion(Node*);
                int rollout(State);
                void backpropagation(Node *node,int addWins,int addLoses,int addSimulations);
        };
        /*************State類別定義**************/
        State::State() :  color(1), gameOver(false) {
            for(int i=0;i&lt64;i++)table[0][i]=-1;
            table[3][3]=table[4][4]=1;
            table[4][3]=table[3][4]=0;
            numberOfPieces[0]=numberOfPieces[1]=0;
            updateLegalStepList();
            updateNumberOfPieces();
        }
        void State::move(int position){
            //position==-1 蒙特卡洛樹搜索找落子位置
            if(position==-1){
                State State=*this;
                MCTS model(State);
                position=model.predict();
                cout&lt&ltposition&lt&lt'\n';
            }
            legalStepList = vector&ltint&gt(0);
            int r=position/8,c=position%8;
            table[r][c]=color;
            for(int direction=0;direction&lt8;direction++)
                flip(position,direction);
            color^=1;
            updateLegalStepList();
            updateNumberOfPieces();
            //沒路走 跳過回合
            if(legalStepList.size()==0){
                color^=1;
                updateLegalStepList();
                //雙方沒路走 遊戲結束
                if(legalStepList.size()==0)
                    gameOver=true;
            }
            return;
        }
        void State::updateNumberOfPieces(void){
            int tmp[2]={};
            for(int i=0;i&lt8;i++)
                for(int j=0;j&lt8;j++)
                    if(table[i][j]!=-1)
                        tmp[table[i][j]]++;
            numberOfPieces[0]=tmp[0];
            numberOfPieces[1]=tmp[1];
        }
        int dr[8]={-1,-1,-1,0,0,1,1,1},dc[8]={-1,0,1,-1,1,-1,0,1};
        void State::updateLegalStepList(){
            set&ltint&gt s;
            for(int i=0;i&lt8;i++)
                for(int j=0;j&lt8;j++)
                    if(table[i][j]==color){
                        for(int direction=0;direction&lt8;direction++){
                            int i1=i+dr[direction],j1=j+dc[direction];
                            if(i1&gt=0 && i1&lt8 && j1&gt=0 && j1&lt8 && table[i1][j1]==(color^1)){
                                int x=findLegalStep(i1*8+j1,direction);
                                if(x!=-1) //有找到
                                    s.insert(x);
                            }

                        }
                    }

            for(int e:s)
                legalStepList.push_back(e);
            return;
        }
        int State::findLegalStep(int position,int direction){
            int r=position/8,c=position%8;
            int r1=r+dr[direction],c1=c+dc[direction];
            if(r1&lt0 || r1&gt=8 || c1&lt0 || c1&gt=8 || table[r1][c1]==color)
                return -1;
            if(table[r1][c1]==(color^1))
                return findLegalStep(r1*8+c1,direction);
            return r1*8+c1;
        }
        bool State::flip(int position,int direction){
            bool flag;
            int r=position/8,c=position%8;
            int r1=r+dr[direction],c1=c+dc[direction];
            if(r1&lt0 || r1&gt=8 || c1&lt0 || c1&gt=8 || table[r1][c1]==-1)//下一個為界外或為空 全部不翻
                flag= false;
            else if(table[r1][c1]==(color^1)) //下一個為敵方 繼續走
                flag= flip(r1*8+c1,direction);
            else if(table[r1][c1]==color)//下一個為我方 全部都翻
                flag=true;
            if(flag)
                table[r][c]=color;
            return flag;
        }
        bool State::isLegal(int position){
            return find(legalStepList.begin(),legalStepList.end(),position)!=legalStepList.end();
        }
        bool State::isGameOver(){
            return gameOver;
        }
        void State::print(){
            for(int i=0;i&lt8;i++){
                for(int j=0;j&lt8;j++){
                    if(table[i][j]==-1)
                        printf("%2d ",i*8+j);
                    else if(table[i][j])
                        cout&lt&lt" B ";
                    else
                        cout&lt&lt" W ";
                }
                cout&lt&lt'\n';
            }
            cout&lt&lt"legalStepList: ";
            for(int e:legalStepList)
                cout&lt&lte&lt&lt' ';
            cout&lt&lt'\n';
            cout&lt&lt"numberOfPieces: "&lt&ltnumberOfPieces[0]&lt&lt' '&lt&ltnumberOfPieces[1]&lt&lt'\n';
            cout&lt&lt"color:"&lt&ltcolor&lt&lt'\n';
            cout&lt&lt"gameOver:"&lt&ltgameOver&lt&lt'\n';
        }
        State::State(json inputData){
            for(int i=0;i&lt64;i++){
                table[0][i]=inputData["gameState"]["table"][i/8][i%8];
            }
            cout&lt&lt1&lt&lt'\n';
            numberOfPieces[0]=inputData["gameState"]["numberOfPieces"][0];
            numberOfPieces[1]=inputData["gameState"]["numberOfPieces"][1];
            cout&lt&lt2&lt&lt'\n';
            for(int i=0;i&ltinputData["gameState"]["legalStepList"].size();i++){
                legalStepList.push_back(inputData["gameState"]["legalStepList"][i]);
            }
            cout&lt&lt3&lt&lt'\n';
            color=inputData["gameState"]["color"];
            gameOver=inputData["gameState"]["gameOver"];
            cout&lt&lt4&lt&lt'\n';
            move(inputData["newPosition"]);
        }
        json State::toJson(){
            json jsonObject;
            jsonObject["color"] = color; // 1 表示颜色值
            jsonObject["gameOver"] = gameOver;
            jsonObject["numberOfPieces"] = {numberOfPieces[0], numberOfPieces[1]};
            jsonObject["legalStepList"] =json::array();
            for(int e:legalStepList)
                jsonObject["legalStepList"].push_back(e);
            jsonObject["table"]=json::array();
            for (int i = 0; i &lt 8; i++) {
                json row;
                for (int j = 0; j &lt 8; j++) {
                    // 在此添加特定的颜色值
                    row.push_back(table[i][j]); // 1 表示颜色值
                }
                jsonObject["table"].push_back(row);
            }
            return jsonObject;
        }
        /*************Node類別定義**************/
        Node::Node(State x):wins(0),loses(0),simulations(0),newPosition(-1),state(x),parent(nullptr),children(vector&ltNode*&gt(0)){}
        void Node::print(){
            cout&lt&lt"========================\n";
            cout&lt&lt"win rate:"&lt&lt(1.*wins/simulations*100)&lt&lt'%'&lt&lt'\n';
            cout&lt&lt"wins:"&lt&ltwins&lt&lt'\n';
            cout&lt&lt"loses:"&lt&ltloses&lt&lt'\n';
            cout&lt&lt"simulations:"&lt&ltsimulations&lt&lt'\n';
            cout&lt&lt"newPosition:"&lt&ltnewPosition&lt&lt'\n';
            state.print();
            cout&lt&lt"========================\n";
        }
        /*************MCTS類別定義**************/
        MCTS::MCTS(State state){
            root=new Node(state);
            expansion(root);
            for(int k=0;k&lt10000;k++){
                Node *node = selection(root);
                int addWins=0,addLoses=0,addSimulations=0;
                if(node-&gtsimulations==0){
                    int x=rollout(node-&gtstate);
                    if(x==node-&gtstate.color)
                        addWins++;
                    else if(x!=-1)
                        addLoses++;
                    addSimulations++;
                }
                else {
                    expansion(node);
                    addSimulations++;
                }

                backpropagation(node,addWins,addLoses,addSimulations);
            }
        }
        MCTS::~MCTS() {
            // 在析构函数中释放节点
            deleteNode(root);
        }
        void MCTS::deleteNode(Node* node) {
            for (Node* child : node-&gtchildren) {
                deleteNode(child);
                delete child;
            }
        }
        double MCTS::UCB(Node* node){
            if(node-&gtsimulations==0)
                return 1000000000;
            double w=node-&gtwins,n=node-&gtsimulations,N=node-&gtparent-&gtsimulations;
            if(node-&gtparent-&gtstate.color != node-&gtstate.color)
                w=node-&gtloses;
            return w/n+sqrt(2*log(N)/n);
        }
        int MCTS::predict(){
            int ret=-1;
            double mx=-1;
            root-&gtprint();
            for(Node* child:root-&gtchildren){
                cout&lt&lt"UCB="&lt&ltUCB(child)&lt&lt'\n';
                child-&gtprint();
                double winRate;
                if(root-&gtstate.color==child-&gtstate.color)
                    winRate=1.*child-&gtwins/child-&gtsimulations;
                else
                    winRate=1.*(child-&gtloses)/child-&gtsimulations;
                if(winRate&gt=mx){
                    mx=winRate;
                    ret=child-&gtnewPosition;
                }

            }
            return ret;
        }
        Node* MCTS::selection(Node* node){
            if(node-&gtchildren.size()==0)
                return node;
            Node *next;
            double mx=0;
            for(Node* child:node-&gtchildren){
                double ucb=UCB(child);
                if(ucb&gtmx){
                    mx=ucb;
                    next=child;
                }

            }
            return selection(next);
        }
        void MCTS::expansion(Node* node){
            vector&ltint&gt v=node-&gtstate.legalStepList;
            for(int pos:v){
                Node *newNode;
                newNode=new Node(node-&gtstate);
                newNode-&gtparent=node;
                newNode-&gtstate.move(pos);
                newNode-&gtnewPosition=pos;
                node-&gtchildren.push_back(newNode);
            }
        }
        int MCTS::rollout(State state){
            if(state.isGameOver()){
                int delta=state.numberOfPieces[1]-state.numberOfPieces[0];
                //cout&lt&lt"rollout result:"&lt&ltdelta&lt&lt'\n';
                if(delta&gt0)
                    return 1;
                if(delta&lt0)
                    return 0;
                return -1;
            }
            int random=rand()%state.legalStepList.size();
            int pos=state.legalStepList[random];
            State newState=state;
            newState.move(pos);
            return rollout(newState);
        }
        void MCTS::backpropagation(Node *node,int addWins,int addLoses,int addSimulations){
            node-&gtwins+=addWins;
            node-&gtloses+=addLoses;
            node-&gtsimulations+=addSimulations;
            if(node-&gtparent==nullptr)
                return;
            if(node-&gtparent-&gtstate.color==node-&gtstate.color)
                backpropagation(node-&gtparent,addWins,addLoses,addSimulations);
            else
                backpropagation(node-&gtparent,addLoses,addWins,addSimulations);
        }
        int main() {
            ifstream ifs("input.json");
            if(!ifs.is_open()){
                cout&lt&lt"input.json開啟失敗\n";
                return 1;
            }

            cout&lt&lt"input.json開啟成功\n";
            json inputData = json::parse(ifs);
            State state(inputData);
            ifs.close();
            cout&lt&lt"input.json 關閉\n";

            json outputData = state.toJson();
            cout&lt&ltoutputData.dump(4);
            // Write JSON data to a file
            ofstream ofs("output.json");
            if (ofs.is_open()) {
                ofs &lt&lt outputData.dump(4); // Write JSON to the file
                ofs.close();
                cout &lt&lt "JSON data has been written to 'output.json'" &lt&lt endl;
            } else {
                cerr &lt&lt "Unable to open the file for writing." &lt&lt endl;
                return 1;
            }

            return 0;
        }

                    
        </code></pre>
        </div>
        <script>
            // 在DOM加载后，运行Prism.js以进行语法高亮
            Prism.highlightAll();
        </script>
        <!-- The Tour Section -->
        <div class="w3-black" id="tour">
            <div class="w3-container w3-content w3-padding-32" style="max-width:690px">
                <h3>棋局 State</h3>
                <p style="color: gray;">負責儲存及更新棋局</p>
                <h3>蒙特卡洛樹搜索 MCTS</h3>
                <p style="color: gray;">負責計算最佳落子位置</p>
            </div>
        </div>
    </div>
    <!-- Footer -->
    <footer class="w3-container w3-padding-64 w3-center w3-opacity w3-light-grey w3-xlarge">
        <i class="fa fa-facebook-official w3-hover-opacity"></i>
        <i class="fa fa-instagram w3-hover-opacity"></i>
        <i class="fa fa-snapchat w3-hover-opacity"></i>
        <i class="fa fa-pinterest-p w3-hover-opacity"></i>
        <i class="fa fa-twitter w3-hover-opacity"></i>
        <i class="fa fa-linkedin w3-hover-opacity"></i>
        <p class="w3-medium">Powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a>
        </p>
    </footer>

</body>

</html>